---
title: Indexación
description: >-
  R proporciona una forma poderosa y conveniente de indexar los vectores. Ahora aprenderemos
  algunas maneras de hacer eso!
---

## Vectores Lógicos

```yaml
type: NormalExercise
key: 010704f684
lang: r
xp: 100
skills:
  - 1
```

Aquí usaremos operadores lógicos para crear un vector lógico.

`@instrucciones`
- Calcule la tasa de homicidios por cada 100,000 para cada estado y guardela en un objeto llamado `murder_rate`. 
- Entonces use los operadores lógicos para crear un vector lógic y nómbralo `low`. Este vector nos dirá cual de las entradas de `murder_rate` son menores de 1, y cuales no lo son, en una sola línea de código.

`@pista`
El código para calcular la tasa de homicidios es: `murders$total/murders$population*100000`.

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Guarde la tasa de homicidios por cada 100,000 para cada estado, en `murder_rate`
murder_rate <- murders$total / murders$population * 100000

# Guarde los valores de tasas de homicidio por cada 100,000 que sean menores que 1, `murder_rate < 1`, en el objeto `low` 
```

`@solution`
```{r}
# Guarde la tasa de homicidios por cada 100,000 para cada estado, en `murder_rate`
murder_rate <- murders$total/murders$population*100000

# Guarde los valores de tasas de homicidio por cada 100,000 que sean menores que 1, `murder_rate < 1`, en el objeto `low` 
low <- murder_rate < 1
```

`@sct`
```{r}
test_error()
test_object("low", undefined_msg = "Define low!", incorrect_msg = "Debe referirse a las tasas de homicidio menores de 1.")
success_msg("Buen trabajo!")
```

---

## which

```yaml
type: NormalExercise
key: 6830d22730
lang: r
xp: 100
skills:
  - 1
```

La función `which()` nos ayuda a saber directamente cuales valores son bajos o altos, etc. Usemosla en este ejercicio.

`@instrucciones`
- Use los resultados del ejercicio anterior y la función `which` para determinar los índices `murder_rate` asociados con los valores menores de 1.

`@pista`
`which` devolverá los lógicos verdaderos (TRUE) .

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Guarde la tasa de homicidios por cada 100,000 para cada estado, en murder_rate
murder_rate <- murders$total/murders$population*100000

# Guarde los valores de murder_rate < 1 en low 
low <- murder_rate < 1

# Obtenga los índices de las entradas menores que 1

```

`@solution`
```{r}
# Guarde la tasa de homicidios por cada 100,000 para cada estado, en murder_rate
murder_rate <- murders$total/murders$population*100000

# Guarde los valores de murder_rate < 1 en low 
low <- murder_rate < 1

# Obtenga los índices de las entradas menores que 1
which(low)

```

`@sct`
```{r}
test_error()
test_output_contains("which(low)", incorrect_msg = "Make sure you use `which` on the correct logical vector!")
test_function("which", incorrect_msg = "Use the command from the instructions.")
success_msg("Awesome!")
```

---

## Ordenando vectores

```yaml
type: NormalExercise
key: d40747abe4
lang: r
xp: 100
skills:
  - 1
```

Note que si queremos saber cuales entradas de un vector son menores que un valor particular podemos utilizar código como el siguiente:

```{r}
small <- murders$population < 1000000
murders$state[small]
```

El código de arriba nos muestra los estados con poblaciones menores que un millón.

`@instrucciones`
- Use los resultados del ejercicio anterior para reportar los nombres de los estados con tasas de homicidio menores que 1, usando los corchetes cuadrados para obtener los nombres de los estados del conjunto de datos.

`@pista`


`@pre_exercise_code`
```{r}
library(dslabs)
data(dslabs)
```

`@sample_code`
```{r}
# Guarde la tasa de homicidio por cada 100,000 para cada estado, en murder_rate
murder_rate <- murders$total/murders$population*100000

# Guarde los valores de murder_rate < 1 en low
low <- murder_rate < 1

# Nombres de estados con tasas de homicidio menores que 1

```

`@solution`
```{r}
# Guarde la tasa de homicidio por cada 100,000 para cada estado, en `murder_rate`
murder_rate <- murders$total/murders$population*100000

# Guarde los valores de `murder_rate` < 1 en `low` 
low <- murder_rate < 1

# Nombres de estados con tasas de homicidio menores que 1
murders$state[low]

```

`@sct`
```{r}
test_error()
test_output_contains("murders$state[low]", incorrect_msg = "Siga el código del ejemplo!")
success_msg("Buen trabajo!")
```

---

## Filtrando

```yaml
type: NormalExercise
key: 68370abd10
lang: r
xp: 100
skills:
  - 1
```



`@instrucciones`
Ahora usaremos el código de los ejercicios anteriores to report the states para reportar los estados en el noreste con una tasa de homicidio menor que 1.
- Defina `low` como lo hizo anteriormente.
- Use el operador `&` para crear un nuevo objeto `ind` que sea verdadero cuando `low` es verdad y el estado está localizado en el noreste.
- Use los corchetes `[` y `ind` para nombrar los nombres de los estados que satisfacen esta condición.

`@pista`
Use el vector lógico `low` anteriormente definido y el operador lógico `&`. Para estados con poblaciones con menos de un millón lucirá así: 

```{r}
ind <- low & murders$population < 1000000

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Guarde la tasa de homicidio por cada 100,000 para cada estado, en `murder_rate`
murder_rate <- murders$total/murders$population*100000

# Guarde los valores de `murder_rate` < 1 en `low` 
low <- murder_rate < 1

# Cree un vector ind para estados localizados en el noreste y con tasas de homicidio menores que 1. 

# Nombres de estados `ind` 

```

`@solution`
```{r}
# Guarde la tasa de homicidio por cada 100,000 para cada estado, en `murder_rate`
murder_rate <- murders$total/murders$population*100000

# Guarde los valores de `murder_rate` < 1 en `low` 
low <- murder_rate < 1

# Estados localizados en el noreste con tasas de homicidio menores que 1; guarde en 'ind'
ind <- low & murders$region=="Northeast"

# Nombres de estados `ind`
murders$state[ind]

```

`@sct`
```{r}
test_error()
test_object("murder_rate", undefined_msg = "Defina murder rate", incorrect_msg = "No cambie nada, solo corra el código.")
test_object("low", undefined_msg = "Defina low!", incorrect_msg = "Lo mismo que el ejercicio anterior.")
test_object("ind", undefined_msg = "Asegúrese de definir ind primero!", incorrect_msg = 'Use el código ind <- low & murders$region=="Northeast".')
test_output_contains("murders$state[ind]", incorrect_msg = "Use [] para obtener los nombres.")
success_msg("Eso estuvo fenomenal! Sigamos con el próximo ejercicio.")
```

---

## Filtering continued

```yaml
type: NormalExercise
key: 11c3753c9c
lang: r
xp: 100
skills:
  - 1
```



`@instructions`
In a previous exercise we computed the murder rate for each state and the average of these numbers.
- How many states are below the average?

`@hint`


`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Store the murder rate per 100,000 for each state, in murder_rate
murder_rate <- murders$total/murders$population*100000


# Compute the average murder rate using `mean` and store it in object named `avg`


# How many states have murder rates below avg ? Check using sum 

```

`@solution`
```{r}
# Store the murder rate per 100,000 for each state, in murder_rate
murder_rate <- murders$total/murders$population*100000

# Compute the average murder rate using `mean` and store it in object named `avg`
avg <-mean(murder_rate)

# How many states are < avg ? Check using sum 
sum(murder_rate < avg)

```

`@sct`
```{r}
test_error()
test_object("murder_rate", undefined_msg = "Define the murder rate first!", incorrect_msg = "Same formula as before.")
test_object("avg", undefined_msg = "", incorrect_msg = "Compute the mean and store it here.")
test_function("sum", incorrect_msg = "Check the number of states below average murder rate.")
test_output_contains("27", incorrect_msg = "Did you count the number of states with a murder rate below `avg`?")
success_msg("Awesome!")
```

---

## Match

```yaml
type: NormalExercise
key: 26843a3448
lang: r
xp: 100
skills:
  - 1
```

In this exercise we use the `match` function to identify the states with abbreviations AK, MI, and IA.

`@instructions`
- Define a character vector with the abbreviations.
- Start by defining an index of the entries of `murders$abb` that match the three abbreviations.
- Use the `[` operator to extract the states.

`@hint`
Once you define `abbs <- c("AK", "MI", "IA")` you can then use match to figure out the indexes of where these appear with `ind <- match(abbs , murders$abb)`

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Store the 3 abbreviations in a vector called `abbs` (remember that they are character vectors and need quotes)

# Match the abbs to the murders$abb and store in ind

# Print state names from ind

```

`@solution`
```{r}
# Store the 3 abbreviations in a vector called `abbs` (remember that they are character vectors and need quotes)
abbs <- c("AK", "MI", "IA")

# Match the abbs to the murders$abb and store in `ind`
ind <- match(abbs , murders$abb)

# Print state names from `ind`
murders$state[ind]

```

`@sct`
```{r}
test_error()
test_object("abbs", undefined_msg = "Define abbs!", incorrect_msg = "Check the abbreviations stored.")
test_object("ind", undefined_msg = "Define ind!", incorrect_msg = "Make sure to use the match function ")
test_output_contains("murders$state[ind]", incorrect_msg = "Use square brackets.")
success_msg("Awesome!")
```

---

## %in%

```yaml
type: NormalExercise
key: 8f682dcf90
lang: r
xp: 100
skills:
  - 1
```

If rather than an index we want a logical that tells us whether or not each element of a first vector is in a second, we can use the function `%in%`.
For example: 

```{r}
x <- c(2, 3, 5)
y <- c(1, 2, 3, 4)
x%in%y
```
Gives us two `TRUE` followed by a `FALSE` because 2 and 3 are in `y` but 5 is not.

`@instructions`
Which of the following are actual abbreviations: MA, ME, MI, MO, MU?
- Define a character vector with the abbreviations MA, ME, MI, MO, MU.
- Use the `%in%` operator to create a logical vector that is TRUE when the abbreviation is in `murders$abb`.

`@hint`
Look at what this does: 
```{r}
states <- c("New York", "Houston")
states%in%murders$state 
```

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Store the 5 abbreviations in `abbs`. (remember that they are character vectors)


# Use the %in% command to check if the entries of abbs are abbreviations in the murders data frame

```

`@solution`
```{r}
# Store the 5 abbreviations in abbs. (remember that they are character vectors)
abbs <- c("MA", "ME", "MI", "MO", "MU") 

# Use the %in% command to check if the entries of abbs are abbreviations in the murders data frame
abbs%in%murders$abb

```

`@sct`
```{r}
test_error()
test_object("abbs", undefined_msg = "Define abbs!", incorrect_msg = "Make sure to store the 5 abbreviations in abbs.")
test_output_contains("abbs%in%murders$abb", incorrect_msg = "Check the code. ")
success_msg("Great job!")
```

---

## Logical operator

```yaml
type: NormalExercise
key: bad79337d1
lang: r
xp: 100
skills:
  - 1
```



`@instructions`
We are again working with the characters `abbs <- c("MA", "ME", "MI", "MO", "MU")`

- In a previous exercise we computed the index `abbs%in%murders$abb`. Based on that, and using the `which` function and the `!` operator, get the index of the entries of `abbs` that are **not** abbreviations.
- Show the entries of `abbs` that are not actual abbreviations.

`@hint`
Use the code `ind <- which(!abbs%in%murders$abb)` to get the index. Then you can use the `[` to extract the correct values of `abbs`.

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Store the 5 abbreviations in abbs. (remember that they are character vectors)
abbs <- c("MA", "ME", "MI", "MO", "MU") 

# Use the `which` command and `!` operator to find out which index abbreviations are not actually part of the dataset and store in `ind`

# Identify abbreviations from `abbs` that are in `ind`

```

`@solution`
```{r}
# Store the 5 abbreviations in `abbs`. (remember that they are character vectors)
abbs <- c("MA", "ME", "MI", "MO", "MU") 

# Use the `which` command and `!` operator to find out which index abbreviations are not actually part of the dataset and store in 'ind' 
ind <- which(!abbs%in%murders$abb)

# Identify abbreviations from `abbs` that are in `ind`
abbs[ind]

```

`@sct`
```{r}
test_error()
test_object("ind", undefined_msg = "Make sure you define ind first!", incorrect_msg = "Use the which and ! codes." )
test_output_contains("abbs[ind]", incorrect_msg = "Review how you are accessing the abbreviations")
success_msg("Awesome!")
```

---

## End of Assessment 6

```yaml
type: PureMultipleChoiceExercise
key: 693e3e8928
lang: r
xp: 50
skills:
  - 1
```

This is the end of the programming assignment for this section. Please DO NOT click through to additional assessments from this page. Please DO answer the question on this page. If you do click through, your scores may NOT be recorded.

Click on "Awesome" to get the "points" for this question and then return to the course on edX.

You can now close this window to go back to the <a href='https://www.edx.org/course/data-science-r-basics-2'>course</a>.

`@hint`
- No hint necessary!

`@possible_answers`
- [Awesome]
- Nope

`@feedback`
- Great! Now navigate back to the course on edX!
- Now navigate back to the course on edX!
