---
<<<<<<< Updated upstream
title: Data Types
description: >-lksjdf;lksjdf
  We're going to get an overview, of the different types of variables that there
  are in R, and how to work with them.
=======
title: Tipos de Datos
description: >-
  Vamos a obtener una comprensión general de los diferentes tipos de variables que existen en R y cómo trabajar con ellos.
>>>>>>> Stashed changes
---

## str

```yaml
type: MultipleChoiceExercise
key: 0e2a0ce37a
lang: r
xp: 50
skills:
  - 1
```


Vamos a utilizar el siguiente conjunto de datos para este módulo.
Ejecute este código en la consola.

```{r}
library(dslabs)
data(murders)
```

A continuación, utilice la función `str` para examinar la estructura del objeto `murders`. Podemos ver que este objeto es un marco de datos con 51 filas y cinco columnas.

¿Cuál de las siguientes describe mejor las variables representadas en este marco de datos?

`@possible_answers`
- Los 51 estados
- Las tasas de homicidios para los 50 estados y DC
- El nombre del estado, la abreviatura del nombre del estado, la región del estado y la población del estado y el número total de asesinatos para 2010.
- `str` no muestra información relevante

`@hint`
Verifique la salida que ve cuando escribe `str (murders)`.

`@pre_exercise_code`
```{r}
library(dslabs)
str(murders) 
```

`@sct`
```{r}
msg1 = "¡Inténtelo de nuevo! Lea la pregunta de nuevo."
msg2 = "¡Inténtelo de nuevo! Lea la pregunta con atención."
msg3 = "Bien hecho. Continúe con el siguiente ejercicio."
msg4 = "¡Inténtelo de nuevo! Revise lo que pide la pregunta."
test_mc(correct = 3, feedback_msgs = c(msg1,msg2,msg3,msg4))
```

---

## Nombres de las variables

```yaml
type: NormalExercise
key: 7455b7cb2b
lang: r
xp: 100
skills:
  - 1
```

En la pregunta anterior, vimos las diferentes variables que forman parte de este conjunto de datos desde la salida de la función `str()`. La función `names()` está específicamente diseñada para extraer los nombres de las columnas de un marco de datos.

`@instructions`
Para esta pregunta, usaremos la función `names()` para extraer los nombres de las columnas del marco de datos `asesinatos`.
- ¿Cuáles son los nombres de columna utilizados por el marco de datos `asesinatos` para las cinco variables?

`@hint`
Asegúrese de poner el nombre del conjunto de datos - `asesinatos` - entre paréntesis después de los nombres.

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Cargar paquete y datos

library(dslabs)
data(murders)

# Utilice la función 'names' para extraer los nombres de las variables.
 
```

`@solution`
```{r}
# Cargar paquete y datos

library(dslabs)
data(murders)

# Utilice la función 'names' para extraer los nombres de las variables.
names(murders)
```

`@sct`
```{r}
test_error()
test_function("names", incorrect_msg = "Asegúrese de haber ingresado el nombre del conjunto de datos.") 
test_output_contains ("names(murders)",times=1,incorrect_msg="Asegúrese de usar la función `names` en el conjunto de datos `murders`")
success_msg("¡Buen trabajo!")
```

---

## Examinando Variables

```yaml
type: NormalExercise
key: efedf86c1b
lang: r
xp: 100
skills:
  - 1
```

En este módulo hemos aprendido que cada variable tiene una clase. Por ejemplo, la clase puede ser un *character* (*carácter*), *numeric* (*numérico*) o *logical* (*lógico*). La función `class()` se puede utilizar para determinar la clase de un objeto.

Aquí vamos a determinar la clase de una de las variables en el marco de datos `murders`. Para extraer variables de un marco de datos, usamos `$`, denominado acceso.

En el editor mostramos un ejemplo de cómo hacer esto. Vamos a probarlo por nosotros mismos.

`@instructions`
Utilice el elemento de acceso `$` para extraer las abreviaturas de estado y asignarlas al objeto `a`.
¿Cuál es la clase de este objeto?

`@hint`
Recuerde asignar las abreviaturas de estado al objeto `a`.

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Para acceder a la variable de 'population' (población) del conjunto de datos de 'murders' (asesinatos), use este código:
p <- murders$population 

# Para determinar la clase del objeto `p` usamos este código:
class(p)

# Utilice el descriptor de acceso para extraer abreviaturas de estado y asignarlo a una variable llamada a

# Determine la clase de la variable a

```

`@solution`
```{r}

# Para acceder a la variable de 'population' (población) del conjunto de datos de 'murders' (asesinatos), use este código:
m <- murders$population 

# Para determinar la clase del objeto `p` usamos este código:
class(m)

# Utilice el descriptor de acceso para extraer abreviaturas de estado y asignarlo a una variable llamada a
a <- murders$abb 

# Determine la clase de la variable a
class(a)  
```

`@sct`
```{r}
test_error()
test_object ("a", undefined_msg = "Necesita definir el objeto `a`.", incorrect_msg = "Asegúrese de guardar la variable `abb` en el objeto `a`.")
test_function("class",index=2,incorrect_msg = "Conserve el código de muestra cuando envíe su solución.")
test_function_result("class",index=2,incorrect_msg = "¡Intenté de nuevo!")
test_student_typed("$", times = 2, not_typed_msg = "Asegúrese de usar la accessor $.")
success_msg("¡Eso es genial! Ahora, ya sabe cuál es la clase de `abb`. ¡Juege para verificar la clase de las otras variables en el conjunto de datos!")
```

---

## Múltiples formas de acceder a las variables

```yaml
type: NormalExercise
key: daeef502c6
lang: r
xp: 100
skills:
  - 1
```

Una lección importante que debe aprender desde el principio es que hay varias formas de hacer las cosas en R. Por ejemplo, para generar los primeros cinco enteros notamos que `1:5` y `seq(1,5)` devuelven el mismo resultado.

También hay varias formas de acceder a las variables en un marco de datos. Por ejemplo, podemos usar los corchetes `[[`
en lugar del descriptor de acceso `$`. El código de ejemplo se incluye en el editor.

Si, en cambio, intenta acceder a una columna con solo un corchete, 


```{r}
murders["population"]
```
R devuelve un subconjunto del marco de datos original que contiene solo esta columna. Este nuevo objeto será de clase `data.frame` en lugar de un vector. Para acceder a la columna en sí, debe usar el descriptor de acceso `$` o los corchetes dobles `[[`.

Los paréntesis, por el contrario, se usan principalmente junto con las funciones para indicar a qué argumento la función debería hacer algo. Por ejemplo, cuando hicimos `class(p)` en la última pregunta, queríamos que la función `class` hiciera algo relacionado con el argumento `p`.

Este es un ejemplo de cómo R puede ser un poco idiosincrásico a veces. Es muy común encontrarlo confuso al principio.

`@instructions`
- Utilice los corchetes `[[` para extraer las abreviaturas de estado y asignarlas al objeto `b`.
- Luego use la función `idéntical` para determinar si  la variable `a`, como se definió en los ejercicios anteriores, y la variable `b` son iguales.

`@hint`
Necesita usar 2 juegos de corchetes.

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
a <- murders$abb 
```

`@sample_code`
```{r}
# Extraemos la población así:
p <- murders$population

# Así hacemos lo mismo con los corchetes:
o <- murders[["population"]] 

# Podemos confirmar que estos dos son iguales.
identical(o, p)

# Utilice corchetes para extraer `abb` de `murders` (asesinatos) y asignarlo a la variable 'b'.

# Compruebe si la variable `a` y la variable `b` son idénticas.

```

`@solution`
```{r}
# Extraemos la población así:
p <- murders$population

# Así hacemos lo mismo con los corchetes:
o <- murders[["population"]] 

# Podemos confirmar que estos dos son iguales.
identical(o, p)

# Utilice corchetes para extraer `abb` de `murders` (asesinatos) y asignarlo a la variable 'b'. 
b <- murders[["abb"]]

# Compruebe si la variable `a` y la variable `b` son idénticas.
identical(a,b)
```

`@sct`
```{r}
test_error()
test_object ("b", undefined_msg = "Necesita definir el objeto `b`.", incorrect_msg = "Asegúrese de guardar la variable `abb` en el objeto `b`.")
test_function("identical",index=2)
test_student_typed("b<-murders[['abb']]",not_typed_msg = "Asegúrese de usar los corchetes dobles en lugar del operador $.")
success_msg("¡Ahora ha aprendido diferentes formas de hacer lo mismo en R! ¡Está haciendo un gran progreso!")
```

---

## Factores

```yaml
type: NormalExercise
key: 1f3a027666
lang: r
xp: 100
skills:
  - 1
```

Usando el comando `str()`, vimos que la columna *region* (*región*) almacena un factor. Puede corroborar esto usando el comando `class` ('clase') en la columna *region*.

La función `levels` ('niveles') nos muestra las categorías para el factor.

`@instrucciones`
- Para esta pregunta combinaremos dos funciones, de forma anidada, para determinar el número de categorías únicas.
Utilice las funciones `levels` ('niveles') y `length` ('longtidu') para determinar el número de regiones definidas por este conjunto de datos y contenidas en `murders$region`.

`@pista`
Asegurese de usar funciones anidadas: `levels` ('niveles') dentro de `length` ('longitud').



`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Podemos ver la clase de la variable region usando la función class
class(murders$region)

# Determine el número de regiones incluidas en esta variable

```

`@solution`
```{r}
# Podemos ver la clase de la variable region usando la función class
class(murders$region)

# Determine el número de regiones incluidas en esta variable
length(levels(murders$region))

```

`@sct`
```{r}
test_error()
test_output_contains("length(levels(murders$region))", incorrect_msg = "Ejecute el código mencionado en las instrucciones exactamente como está.")
test_function("length")
test_function("levels")
success_msg("¡Buen trabajo!")
```

---

## Tablas

```yaml
type: NormalExercise
key: 50874dd0d0
lang: r
xp: 100
skills:
  - 1
```

La función `table` ('tabla') toma un vector como entrada y devuelve la frecuencia de cada elemento único en el vector. (Tenga en cuenta que verá la función `c()` utilizada en nuestro código de muestra, pero solo la estamos usando aquí para crear un vector al que podemos aplicar la función `table()` como ejemplo).

`@instrucciones`
Usaremos la función `table` ('tabla') para responder a esta pregunta.
- Use la función `table` ('tabla') en una línea de código para crear una tabla que muestre el número de estados por región.

`@pista`
Extraiga la variable *region* (*región*) del conjunto de datos `murders` usando `murders$region`. Si aplica la función `table` ('tabla') a este objeto, la función contará el número de veces que aparece cada región.

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# The "c" in `c()` is short for "concatenate," which is the action of connecting items into a chain
# The function `c()` connects all of the strings within it into a single vector, which we can assign to `x`
# Here, we are simply using `c()` to generate a vector to which we can apply the `table()` function
x <- c("a", "a", "b", "b", "b", "c")
# Here is an example of what the table function does
table(x)

# Write one line of code to show the number of states per region

```

`@solution`
```{r}
# The "c" in `c()` is short for "concatenate," which is the action of connecting items into a chain
# The function `c()` connects all of the strings within it into a single vector, which we can assign to `x`
# Here, we are simply using `c()` to generate a vector to which we can apply the `table()` function
x <- c("a", "a", "b", "b", "b", "c")
# Here is an example of what the table function does
table(x)

# Write one line of code to show the number of states per region
table(murders$region)

```

`@sct`
```{r}
test_error()
test_function("table",index=2, incorrect_msg = "Make sure you extract the variable region from the dataset.",not_called_msg = "Keep the sample code.")
test_output_contains("table(murders$region)",incorrect_msg = "Use table on the murders$region variable.")
success_msg("You got this! Now you're a pro at making tables in R!")
```

---

## End of Assessment 2

```yaml
type: PureMultipleChoiceExercise
key: 2af8480751
lang: r
xp: 50
skills:
  - 1
```

This is the end of the programming assignment for this section. Please DO NOT click through to additional assessments from this page. Please DO answer the question on this page. If you do click through, your scores may NOT be recorded.

Click on "Awesome" to get the "points" for this question and then return to the course on edX.

You can now close this window to go back to the <a href='https://www.edx.org/course/data-science-r-basics-2'>course</a>.

`@hint`
- No hint necessary!

`@possible_answers`
- [Awesome]
- Nope

`@feedback`
- Great! Now navigate back to the course on edX!
- Now navigate back to the course on edX!
